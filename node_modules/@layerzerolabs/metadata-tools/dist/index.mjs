// src/config-metadata.ts
var METADATA_URL = process.env.LZ_METADATA_URL || "https://metadata.layerzero-api.com/v1/metadata";
function getEndpointIdDeployment(eid, metadata) {
  const srcEidString = eid.toString();
  for (const objectKey in metadata) {
    const entry = metadata[objectKey];
    if (typeof (entry == null ? void 0 : entry.deployments) !== "undefined") {
      for (const deployment of entry.deployments) {
        if (srcEidString === deployment.eid) {
          return deployment;
        }
      }
    }
  }
  throw new Error(`Can't find endpoint with eid: "${eid}",`);
}
function DVNsToAddresses(dvns, chainKey, metadata) {
  var _a;
  if (dvns.length === 0) {
    return [];
  }
  const dvnAddresses = [];
  const seenDVNs = /* @__PURE__ */ new Set();
  if (!((_a = metadata[chainKey]) == null ? void 0 : _a.dvns)) {
    throw new Error(`Can't find DVNs for chainKey: "${chainKey}".`);
  }
  const metadataDVNs = Object.entries(metadata[chainKey].dvns);
  for (const dvn of dvns) {
    if (seenDVNs.has(dvn)) {
      throw new Error(`Duplicate DVN name found: "${dvn}".`);
    }
    seenDVNs.add(dvn);
    let i = 0;
    for (const [dvnAddress, dvnDetails] of metadataDVNs) {
      if (!dvnDetails.deprecated && dvnDetails.canonicalName === dvn && !dvnDetails.lzReadCompatible && dvnDetails.version === 2) {
        dvnAddresses.push(dvnAddress);
        break;
      }
      if (i === metadataDVNs.length - 1) {
        throw new Error(
          `Can't find DVN: "${dvn}" on chainKey: "${chainKey}". Double check you're using valid DVN canonical name (not an address).`
        );
      }
      i++;
    }
  }
  if (dvns.length !== dvnAddresses.length) {
    throw new Error(`Can't find all DVNs: "${dvns.join(", ")}".`);
  }
  return dvnAddresses.sort();
}
function isSolanaDeployment(deployment) {
  return deployment.chainKey.startsWith("solana");
}
async function translatePathwayToConfig(pathway, metadata) {
  var _a, _b, _c, _d;
  const configs = [];
  const sourceContract = pathway[0];
  const destinationContract = pathway[1];
  const [requiredDVNs, optionalDVNConfig] = pathway[2];
  const [sourceToDestinationConfirmations, destinationToSourceConfirmations] = pathway[3];
  const [enforcedOptionsSrcToDst, enforcedOptionsDstToSrc] = pathway[4];
  const optionalDVNs = optionalDVNConfig[0];
  const optionalDVNThreshold = optionalDVNConfig[1] || 0;
  if (optionalDVNThreshold > ((optionalDVNs == null ? void 0 : optionalDVNs.length) || 0)) {
    throw new Error(`Optional DVN threshold is greater than the number of optional DVNs.`);
  }
  const sourceLZDeployment = getEndpointIdDeployment(sourceContract.eid, metadata);
  const destinationLZDeployment = getEndpointIdDeployment(destinationContract.eid, metadata);
  const sourceExecutor = isSolanaDeployment(sourceLZDeployment) ? (_a = sourceLZDeployment.executor) == null ? void 0 : _a.pda : (_b = sourceLZDeployment.executor) == null ? void 0 : _b.address;
  if (!sourceExecutor) {
    throw new Error(`Can't find executor for source endpoint with eid: "${sourceContract.eid}".`);
  }
  const sourceRequiredDVNs = DVNsToAddresses(requiredDVNs, sourceLZDeployment.chainKey, metadata);
  const destinationRequiredDVNs = DVNsToAddresses(requiredDVNs, destinationLZDeployment.chainKey, metadata);
  let sourceOptionalDVNs = [];
  let destinationOptionalDVNs = [];
  if (optionalDVNs) {
    sourceOptionalDVNs = DVNsToAddresses(optionalDVNs, sourceLZDeployment.chainKey, metadata);
    destinationOptionalDVNs = DVNsToAddresses(optionalDVNs, destinationLZDeployment.chainKey, metadata);
  }
  if (!sourceLZDeployment.sendUln302 || !sourceLZDeployment.receiveUln302 || !sourceLZDeployment.executor) {
    throw new Error(
      `Can't find sendUln302, receiveUln302 or executor for source endpoint with eid: "${sourceContract.eid}".`
    );
  }
  if (!destinationLZDeployment.sendUln302 || !destinationLZDeployment.receiveUln302 || !destinationLZDeployment.executor) {
    throw new Error(
      `Can't find sendUln302, receiveUln302 or executor for destination endpoint with eid: "${destinationContract.eid}".`
    );
  }
  const sourceToDestinationConfig = {
    from: sourceContract,
    to: destinationContract,
    config: {
      sendLibrary: sourceLZDeployment.sendUln302.address,
      receiveLibraryConfig: {
        receiveLibrary: sourceLZDeployment.receiveUln302.address,
        gracePeriod: BigInt(0)
      },
      sendConfig: {
        executorConfig: {
          maxMessageSize: 1e4,
          executor: sourceExecutor
        },
        ulnConfig: {
          confirmations: BigInt(sourceToDestinationConfirmations),
          requiredDVNs: sourceRequiredDVNs,
          optionalDVNs: sourceOptionalDVNs,
          optionalDVNThreshold
        }
      },
      enforcedOptions: enforcedOptionsSrcToDst
    }
  };
  const destinationToSourceConfig = {
    from: destinationContract,
    to: sourceContract,
    config: {
      sendLibrary: destinationLZDeployment.sendUln302.address,
      receiveLibraryConfig: {
        receiveLibrary: destinationLZDeployment.receiveUln302.address,
        gracePeriod: BigInt(0)
      },
      receiveConfig: {
        ulnConfig: {
          confirmations: BigInt(sourceToDestinationConfirmations),
          requiredDVNs: destinationRequiredDVNs,
          optionalDVNs: destinationOptionalDVNs,
          optionalDVNThreshold
        }
      }
    }
  };
  if (destinationToSourceConfirmations) {
    const destinationExecutor = isSolanaDeployment(destinationLZDeployment) ? (_c = destinationLZDeployment.executor) == null ? void 0 : _c.pda : (_d = destinationLZDeployment.executor) == null ? void 0 : _d.address;
    if (!destinationExecutor) {
      throw new Error(`Can't find executor for destination endpoint with eid: "${destinationContract.eid}".`);
    }
    sourceToDestinationConfig.config.receiveConfig = {
      ulnConfig: {
        confirmations: BigInt(destinationToSourceConfirmations),
        requiredDVNs: sourceRequiredDVNs,
        optionalDVNs: sourceOptionalDVNs,
        optionalDVNThreshold
      }
    };
    destinationToSourceConfig.config.enforcedOptions = enforcedOptionsDstToSrc;
    destinationToSourceConfig.config.sendConfig = {
      executorConfig: {
        maxMessageSize: 1e4,
        executor: destinationExecutor
      },
      ulnConfig: {
        confirmations: BigInt(destinationToSourceConfirmations),
        requiredDVNs: destinationRequiredDVNs,
        optionalDVNs: destinationOptionalDVNs,
        optionalDVNThreshold
      }
    };
  }
  configs.push(sourceToDestinationConfig);
  configs.push(destinationToSourceConfig);
  return configs;
}
async function generateConnectionsConfig(pathways) {
  const metadata = await fetch(METADATA_URL).then((res) => res.json());
  const connections = [];
  for (const pathway of pathways) {
    connections.push(...await translatePathwayToConfig(pathway, metadata));
  }
  return connections;
}

export { DVNsToAddresses, generateConnectionsConfig, translatePathwayToConfig };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map